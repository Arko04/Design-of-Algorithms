// this code is generated by chatGPT but i coudn't get the link to that because my chatGPT crashed 
// at the end of the day. So if my chatGPT works, i will provide you my promp, but i think this 
// will not work for a few days. but i should tell you i got help from chatGPT 
// I asked at first calculate the minimum cost of a MST.
// then i want him to force add the requested edges in each query and check wether it creates cycle
// and if it was okay, apply kruskal algorithm for the rest of the edges and then check if the 
// cost of tree is equal to the cost of the MST we calculate it before

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include <unordered_map>

using namespace std;
struct Edge {
    int u, v, w, index;
    bool operator<(const Edge &other) const {
        return w < other.w; // Sort by weight
    }
    bool operator==(const Edge &other) const {
        return (u == other.u && v == other.v) || (u == other.v && v == other.u);
    }
};
unordered_map <int, Edge> index_to_edge;

class UnionFind {
    vector<int> parent, rank;

public:
    UnionFind(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        iota(parent.begin(), parent.end(), 0); // Initialize parent
    }

    int find(int u) {
        if (u != parent[u]) {
            parent[u] = find(parent[u]); // Path compression
        }
        return parent[u];
    }

    bool unite(int u, int v) {
        int pu = find(u), pv = find(v);
        parent[u] = pu; parent[v] = pv;
        if (pu == pv) return false; // Cycle detected
        if (rank[pu] < rank[pv]) swap(pu, pv);
        parent[pv] = pu; // Union by rank
        if (rank[pu] == rank[pv]) rank[pu]++;
        return true; // Successfully united
    }
};

int n, m;
vector<Edge> edges;

long long computeMST(const vector<Edge> &edgesToAdd = {}) {
    UnionFind uf(n); // Use zero-based indexing
    long long cost = 0;
    vector<Edge> mst;

    // Include required edges first, checking for cycles
    for (const auto &edge : edgesToAdd) {
        if (!uf.unite(edge.u, edge.v)) {
            return -1; // Cycle detected, invalid request
        }
        cost += edge.w; // Add weight to cost
        mst.push_back(edge);
    }

    // Add remaining edges
    for (const auto &edge : edges) {

        if (uf.unite(edge.u, edge.v)) {
            cost += edge.w; // Add weight to cost
            mst.push_back(edge);
        }
        if (mst.size() == n - 1) // Stop if MST is complete
            break;
    }

    return (mst.size() == n - 1) ? cost : -1; // Return cost or -1 if not connected
}

int main() {
    cin >> n >> m;
    edges.resize(m);

    for (int i = 0; i < m; i++) {
        cin >> edges[i].u >> edges[i].v >> edges[i].w;
        edges[i].u--; // Convert to zero-based index
        edges[i].v--; // Convert to zero-based index
        edges[i].index = i; // Store the original index of the edge
        index_to_edge[i] = edges[i];

    }

    // Sort edges by weight for Kruskal's algorithm
    sort(edges.begin(), edges.end());

    // Compute the initial MST
    long long baseMSTCost = computeMST();

    int q;
    cin >> q;
    while (q--) {
        int k;
        cin >> k;
        vector<Edge> requiredEdges;
        vector<int> indices(k);

        for (int i = 0; i < k; i++) {
            int idx;
            cin >> idx; // Read index of the required edge
            indices[i] = idx - 1; // Convert to zero-based index
            requiredEdges.push_back(index_to_edge[indices[i]]);
        }

        // Compute MST with the requested edges
        long long costWithRequest = computeMST(requiredEdges);

        // Check if it's still minimal
        if (costWithRequest != -1 && costWithRequest == baseMSTCost) {
            cout << "YES\n"; // The requested edges can be part of an MST
        } else {
            cout << "NO\n"; // Not possible to include the requested edges
        }
    }

    return 0;
}